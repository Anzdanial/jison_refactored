<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - lib/jison.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>lib/jison.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">61.84</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">1915</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">153.50</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">24.82</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">// Jison, an LR(0), SLR(1), LARL(1), LR(1) Parser Generator
// Zachary Carter &lt;zach@carter.name&gt;
// MIT X Licensed

var typal      = require(&#039;./util/typal&#039;).typal;
var Set        = require(&#039;./util/set&#039;).Set;
var Lexer      = require(&#039;jison-lex&#039;);
var ebnfParser = require(&#039;ebnf-parser&#039;);
var JSONSelect = require(&#039;JSONSelect&#039;);
var esprima    = require(&#039;esprima&#039;);
var escodegen  = require(&#039;escodegen&#039;);


var version = require(&#039;../package.json&#039;).version;

var Jison = exports.Jison = exports;
Jison.version = version;

// detect print
if (typeof console !== &#039;undefined&#039; &amp;&amp; console.log) {
    Jison.print = console.log;
} else if (typeof puts !== &#039;undefined&#039;) {
    Jison.print = function print () { puts([].join.call(arguments, &#039; &#039;)); };
} else if (typeof print !== &#039;undefined&#039;) {
    Jison.print = print;
} else {
    Jison.print = function print () {};
}

Jison.Parser = (function () {

// iterator utility
function each (obj, func) {
    if (obj.forEach) {
        obj.forEach(func);
    } else {
        var p;
        for (p in obj) {
            if (obj.hasOwnProperty(p)) {
                func.call(obj, obj[p], p, obj);
            }
        }
    }
}

var Nonterminal = typal.construct({
    constructor: function Nonterminal (symbol) {
        this.symbol = symbol;
        this.productions = new Set();
        this.first = [];
        this.follows = [];
        this.nullable = false;
    },
    toString: function Nonterminal_toString () {
        var str = this.symbol+&quot;\n&quot;;
        str += (this.nullable ? &#039;nullable&#039; : &#039;not nullable&#039;);
        str += &quot;\nFirsts: &quot;+this.first.join(&#039;, &#039;);
        str += &quot;\nFollows: &quot;+this.first.join(&#039;, &#039;);
        str += &quot;\nProductions:\n  &quot;+this.productions.join(&#039;\n  &#039;);

        return str;
    }
});

var Production = typal.construct({
    constructor: function Production (symbol, handle, id) {
        this.symbol = symbol;
        this.handle = handle;
        this.nullable = false;
        this.id = id;
        this.first = [];
        this.precedence = 0;
    },
    toString: function Production_toString () {
        return this.symbol+&quot; -&gt; &quot;+this.handle.join(&#039; &#039;);
    }
});

var generator = typal.beget();

generator.constructor = function Jison_Generator (grammar, opt) {
    if (typeof grammar === &#039;string&#039;) {
        grammar = ebnfParser.parse(grammar);
    }

    var options = typal.mix.call({}, grammar.options, opt);
    this.terms = {};
    this.operators = {};
    this.productions = [];
    this.conflicts = 0;
    this.resolutions = [];
    this.options = options;
    this.parseParams = grammar.parseParams;
    this.yy = {}; // accessed as yy free variable in the parser/lexer actions

    // source included in semantic action execution scope
    if (grammar.actionInclude) {
        if (typeof grammar.actionInclude === &#039;function&#039;) {
            grammar.actionInclude = String(grammar.actionInclude).replace(/^\s*function \(\) \{/, &#039;&#039;).replace(/\}\s*$/, &#039;&#039;);
        }
        this.actionInclude = grammar.actionInclude;
    }
    this.moduleInclude = grammar.moduleInclude || &#039;&#039;;

    this.DEBUG = options.debug || false;
    if (this.DEBUG) this.mix(generatorDebug); // mixin debug methods

    this.processGrammar(grammar);

    if (grammar.lex) {
        this.lexer = new Lexer(grammar.lex, null, this.terminals_);
    }
};

generator.processGrammar = function processGrammarDef (grammar) {
    var bnf = grammar.bnf,
        tokens = grammar.tokens,
        nonterminals = this.nonterminals = {},
        productions = this.productions,
        self = this;

    if (!grammar.bnf &amp;&amp; grammar.ebnf) {
        bnf = grammar.bnf = ebnfParser.transform(grammar.ebnf);
    }

    if (tokens) {
        if (typeof tokens === &#039;string&#039;) {
            tokens = tokens.trim().split(&#039; &#039;);
        } else {
            tokens = tokens.slice(0);
        }
    }

    var symbols = this.symbols = [];

    // calculate precedence of operators
    var operators = this.operators = processOperators(grammar.operators);

    // build productions from cfg
    this.buildProductions(bnf, productions, nonterminals, symbols, operators);

    if (tokens &amp;&amp; this.terminals.length !== tokens.length) {
        self.trace(&quot;Warning: declared tokens differ from tokens found in rules.&quot;);
        self.trace(this.terminals);
        self.trace(tokens);
    }

    // augment the grammar
    this.augmentGrammar(grammar);
};

generator.augmentGrammar = function augmentGrammar (grammar) {
    if (this.productions.length === 0) {
        throw new Error(&quot;Grammar error: must have at least one rule.&quot;);
    }
    // use specified start symbol, or default to first user defined production
    this.startSymbol = grammar.start || grammar.startSymbol || this.productions[0].symbol;
    if (!this.nonterminals[this.startSymbol]) {
        throw new Error(&quot;Grammar error: startSymbol must be a non-terminal found in your grammar.&quot;);
    }
    this.EOF = &quot;$end&quot;;

    // augment the grammar
    var acceptProduction = new Production(&#039;$accept&#039;, [this.startSymbol, &#039;$end&#039;], 0);
    this.productions.unshift(acceptProduction);

    // prepend parser tokens
    this.symbols.unshift(&quot;$accept&quot;,this.EOF);
    this.symbols_.$accept = 0;
    this.symbols_[this.EOF] = 1;
    this.terminals.unshift(this.EOF);

    this.nonterminals.$accept = new Nonterminal(&quot;$accept&quot;);
    this.nonterminals.$accept.productions.push(acceptProduction);

    // add follow $ to start symbol
    this.nonterminals[this.startSymbol].follows.push(this.EOF);
};

// set precedence and associativity of operators
function processOperators (ops) {
    if (!ops) return {};
    var operators = {};
    for (var i=0,k,prec;prec=ops[i]; i++) {
        for (k=1;k &lt; prec.length;k++) {
            operators[prec[k]] = {precedence: i+1, assoc: prec[0]};
        }
    }
    return operators;
}


generator.buildProductions = function buildProductions(bnf, productions, nonterminals, symbols, operators) {
    var actions = [
      &#039;/* this == yyval */&#039;,
      this.actionInclude || &#039;&#039;,
      &#039;var $0 = $$.length - 1;&#039;,
      &#039;switch (yystate) {&#039;
    ];
    var actionGroups = {};
    var prods, symbol;
    var productions_ = [0];
    var symbolId = 1;
    var symbols_ = {};

    var her = false; // has error recovery

    function addSymbol (s) {
        if (s &amp;&amp; !symbols_[s]) {
            symbols_[s] = ++symbolId;
            symbols.push(s);
        }
    }

    // add error symbol; will be third symbol, or &quot;2&quot; ($accept, $end, error)
    addSymbol(&quot;error&quot;);

    for (symbol in bnf) {
        if (!bnf.hasOwnProperty(symbol)) continue;

        addSymbol(symbol);
        nonterminals[symbol] = new Nonterminal(symbol);

        if (typeof bnf[symbol] === &#039;string&#039;) {
            prods = bnf[symbol].split(/\s*\|\s*/g);
        } else {
            prods = bnf[symbol].slice(0);
        }

        prods.forEach(buildProduction);
    }
    for (var action in actionGroups)
      actions.push(actionGroups[action].join(&#039; &#039;), action, &#039;break;&#039;);

    var sym, terms = [], terms_ = {};
    each(symbols_, function (id, sym) {
        if (!nonterminals[sym]) {
            terms.push(sym);
            terms_[id] = sym;
        }
    });

    this.hasErrorRecovery = her;

    this.terminals = terms;
    this.terminals_ = terms_;
    this.symbols_ = symbols_;

    this.productions_ = productions_;
    actions.push(&#039;}&#039;);

    actions = actions.join(&quot;\n&quot;)
                .replace(/YYABORT/g, &#039;return false&#039;)
                .replace(/YYACCEPT/g, &#039;return true&#039;);

    var parameters = &quot;yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */&quot;;
    if (this.parseParams) parameters += &#039;, &#039; + this.parseParams.join(&#039;, &#039;);

    this.performAction = &quot;function anonymous(&quot; + parameters + &quot;) {\n&quot; + actions + &quot;\n}&quot;;

    function buildProduction (handle) {
        var r, rhs, i;
        if (handle.constructor === Array) {
            rhs = (typeof handle[0] === &#039;string&#039;) ?
                      handle[0].trim().split(&#039; &#039;) :
                      handle[0].slice(0);

            for (i=0; i&lt;rhs.length; i++) {
                if (rhs[i] === &#039;error&#039;) her = true;
                if (!symbols_[rhs[i]]) {
                    addSymbol(rhs[i]);
                }
            }

            if (typeof handle[1] === &#039;string&#039; || handle.length == 3) {
                // semantic action specified
                var label = &#039;case &#039; + (productions.length+1) + &#039;:&#039;, action = handle[1];

                // replace named semantic values ($nonterminal)
                if (action.match(/[$@][a-zA-Z][a-zA-Z0-9_]*/)) {
                    var count = {},
                        names = {};
                    for (i=0;i&lt;rhs.length;i++) {
                        // check for aliased names, e.g., id[alias]
                        var rhs_i = rhs[i].match(/\[[a-zA-Z][a-zA-Z0-9_-]*\]/);
                        if (rhs_i) {
                            rhs_i = rhs_i[0].substr(1, rhs_i[0].length-2);
                            rhs[i] = rhs[i].substr(0, rhs[i].indexOf(&#039;[&#039;));
                        } else {
                            rhs_i = rhs[i];
                        }

                        if (names[rhs_i]) {
                            names[rhs_i + (++count[rhs_i])] = i+1;
                        } else {
                            names[rhs_i] = i+1;
                            names[rhs_i + &quot;1&quot;] = i+1;
                            count[rhs_i] = 1;
                        }
                    }
                    action = action.replace(/\$([a-zA-Z][a-zA-Z0-9_]*)/g, function (str, pl) {
                            return names[pl] ? &#039;$&#039;+names[pl] : str;
                        }).replace(/@([a-zA-Z][a-zA-Z0-9_]*)/g, function (str, pl) {
                            return names[pl] ? &#039;@&#039;+names[pl] : str;
                        });
                }
                action = action
                    // replace references to $$ with this.$, and @$ with this._$
                    .replace(/([^&#039;&quot;])\$\$|^\$\$/g, &#039;$1this.$&#039;).replace(/@[0$]/g, &quot;this._$&quot;)

                    // replace semantic value references ($n) with stack value (stack[n])
                    .replace(/\$(-?\d+)/g, function (_, n) {
                        return &quot;$$[$0&quot; + (parseInt(n, 10) - rhs.length || &#039;&#039;) + &quot;]&quot;;
                    })
                    // same as above for location references (@n)
                    .replace(/@(-?\d+)/g, function (_, n) {
                        return &quot;_$[$0&quot; + (n - rhs.length || &#039;&#039;) + &quot;]&quot;;
                    });
                if (action in actionGroups) actionGroups[action].push(label);
                else actionGroups[action] = [label];

                // done with aliases; strip them.
                rhs = rhs.map(function(e,i) { return e.replace(/\[[a-zA-Z_][a-zA-Z0-9_-]*\]/g, &#039;&#039;) });
                r = new Production(symbol, rhs, productions.length+1);
                // precedence specified also
                if (handle[2] &amp;&amp; operators[handle[2].prec]) {
                    r.precedence = operators[handle[2].prec].precedence;
                }
            } else {
                // no action -&gt; don&#039;t care about aliases; strip them.
                rhs = rhs.map(function(e,i) { return e.replace(/\[[a-zA-Z_][a-zA-Z0-9_-]*\]/g, &#039;&#039;) });
                // only precedence specified
                r = new Production(symbol, rhs, productions.length+1);
                if (operators[handle[1].prec]) {
                    r.precedence = operators[handle[1].prec].precedence;
                }
            }
        } else {
            // no action -&gt; don&#039;t care about aliases; strip them.
            handle = handle.replace(/\[[a-zA-Z_][a-zA-Z0-9_-]*\]/g, &#039;&#039;);
            rhs = handle.trim().split(&#039; &#039;);
            for (i=0; i&lt;rhs.length; i++) {
                if (rhs[i] === &#039;error&#039;) her = true;
                if (!symbols_[rhs[i]]) {
                    addSymbol(rhs[i]);
                }
            }
            r = new Production(symbol, rhs, productions.length+1);
        }
        if (r.precedence === 0) {
            // set precedence
            for (i=r.handle.length-1; i&gt;=0; i--) {
                if (!(r.handle[i] in nonterminals) &amp;&amp; r.handle[i] in operators) {
                    r.precedence = operators[r.handle[i]].precedence;
                }
            }
        }

        productions.push(r);
        productions_.push([symbols_[r.symbol], r.handle[0] === &#039;&#039; ? 0 : r.handle.length]);
        nonterminals[symbol].productions.push(r);
    }
};



generator.createParser = function createParser () {
    throw new Error(&#039;Calling abstract method.&#039;);
};

// noop. implemented in debug mixin
generator.trace = function trace () { };

generator.warn = function warn () {
    var args = Array.prototype.slice.call(arguments,0);
    Jison.print.call(null,args.join(&quot;&quot;));
};

generator.error = function error (msg) {
    throw new Error(msg);
};

// Generator debug mixin

var generatorDebug = {
    trace: function trace () {
        Jison.print.apply(null, arguments);
    },
    beforeprocessGrammar: function () {
        this.trace(&quot;Processing grammar.&quot;);
    },
    afteraugmentGrammar: function () {
        var trace = this.trace;
        each(this.symbols, function (sym, i) {
            trace(sym+&quot;(&quot;+i+&quot;)&quot;);
        });
    }
};



/*
 * Mixin for common behaviors of lookahead parsers
 * */
var lookaheadMixin = {};

lookaheadMixin.computeLookaheads = function computeLookaheads () {
    if (this.DEBUG) this.mix(lookaheadDebug); // mixin debug methods

    this.computeLookaheads = function () {};
    this.nullableSets();
    this.firstSets();
    this.followSets();
};

// calculate follow sets typald on first and nullable
lookaheadMixin.followSets = function followSets () {
    var productions = this.productions,
        nonterminals = this.nonterminals,
        self = this,
        cont = true;

    // loop until no further changes have been made
    while(cont) {
        cont = false;

        productions.forEach(function Follow_prod_forEach (production, k) {
            //self.trace(production.symbol,nonterminals[production.symbol].follows);
            // q is used in Simple LALR algorithm determine follows in context
            var q;
            var ctx = !!self.go_;

            var set = [],oldcount;
            for (var i=0,t;t=production.handle[i];++i) {
                if (!nonterminals[t]) continue;

                // for Simple LALR algorithm, self.go_ checks if
                if (ctx)
                    q = self.go_(production.symbol, production.handle.slice(0, i));
                var bool = !ctx || q === parseInt(self.nterms_[t], 10);

                if (i === production.handle.length+1 &amp;&amp; bool) {
                    set = nonterminals[production.symbol].follows;
                } else {
                    var part = production.handle.slice(i+1);

                    set = self.first(part);
                    if (self.nullable(part) &amp;&amp; bool) {
                        set.push.apply(set, nonterminals[production.symbol].follows);
                    }
                }
                oldcount = nonterminals[t].follows.length;
                Set.union(nonterminals[t].follows, set);
                if (oldcount !== nonterminals[t].follows.length) {
                    cont = true;
                }
            }
        });
    }
};

// return the FIRST set of a symbol or series of symbols
lookaheadMixin.first = function first (symbol) {
    // epsilon
    if (symbol === &#039;&#039;) {
        return [];
    // RHS
    } else if (symbol instanceof Array) {
        var firsts = [];
        for (var i=0,t;t=symbol[i];++i) {
            if (!this.nonterminals[t]) {
                if (firsts.indexOf(t) === -1)
                    firsts.push(t);
            } else {
                Set.union(firsts, this.nonterminals[t].first);
            }
            if (!this.nullable(t))
                break;
        }
        return firsts;
    // terminal
    } else if (!this.nonterminals[symbol]) {
        return [symbol];
    // nonterminal
    } else {
        return this.nonterminals[symbol].first;
    }
};

// fixed-point calculation of FIRST sets
lookaheadMixin.firstSets = function firstSets () {
    var productions = this.productions,
        nonterminals = this.nonterminals,
        self = this,
        cont = true,
        symbol,firsts;

    // loop until no further changes have been made
    while(cont) {
        cont = false;

        productions.forEach(function FirstSets_forEach (production, k) {
            var firsts = self.first(production.handle);
            if (firsts.length !== production.first.length) {
                production.first = firsts;
                cont=true;
            }
        });

        for (symbol in nonterminals) {
            firsts = [];
            nonterminals[symbol].productions.forEach(function (production) {
                Set.union(firsts, production.first);
            });
            if (firsts.length !== nonterminals[symbol].first.length) {
                nonterminals[symbol].first = firsts;
                cont=true;
            }
        }
    }
};

// fixed-point calculation of NULLABLE
lookaheadMixin.nullableSets = function nullableSets () {
    var firsts = this.firsts = {},
        nonterminals = this.nonterminals,
        self = this,
        cont = true;

    // loop until no further changes have been made
    while(cont) {
        cont = false;

        // check if each production is nullable
        this.productions.forEach(function (production, k) {
            if (!production.nullable) {
                for (var i=0,n=0,t;t=production.handle[i];++i) {
                    if (self.nullable(t)) n++;
                }
                if (n===i) { // production is nullable if all tokens are nullable
                    production.nullable = cont = true;
                }
            }
        });

        //check if each symbol is nullable
        for (var symbol in nonterminals) {
            if (!this.nullable(symbol)) {
                for (var i=0,production;production=nonterminals[symbol].productions.item(i);i++) {
                    if (production.nullable)
                        nonterminals[symbol].nullable = cont = true;
                }
            }
        }
    }
};

// check if a token or series of tokens is nullable
lookaheadMixin.nullable = function nullable (symbol) {
    // epsilon
    if (symbol === &#039;&#039;) {
        return true;
    // RHS
    } else if (symbol instanceof Array) {
        for (var i=0,t;t=symbol[i];++i) {
            if (!this.nullable(t))
                return false;
        }
        return true;
    // terminal
    } else if (!this.nonterminals[symbol]) {
        return false;
    // nonterminal
    } else {
        return this.nonterminals[symbol].nullable;
    }
};


// lookahead debug mixin
var lookaheadDebug = {
    beforenullableSets: function () {
        this.trace(&quot;Computing Nullable sets.&quot;);
    },
    beforefirstSets: function () {
        this.trace(&quot;Computing First sets.&quot;);
    },
    beforefollowSets: function () {
        this.trace(&quot;Computing Follow sets.&quot;);
    },
    afterfollowSets: function () {
        var trace = this.trace;
        each(this.nonterminals, function (nt, t) {
            trace(nt, &#039;\n&#039;);
        });
    }
};

/*
 * Mixin for common LR parser behavior
 * */
var lrGeneratorMixin = {};

lrGeneratorMixin.buildTable = function buildTable () {
    if (this.DEBUG) this.mix(lrGeneratorDebug); // mixin debug methods

    this.states = this.canonicalCollection();
    this.table = this.parseTable(this.states);
    this.defaultActions = findDefaults(this.table);
};

lrGeneratorMixin.Item = typal.construct({
    constructor: function Item(production, dot, f, predecessor) {
        this.production = production;
        this.dotPosition = dot || 0;
        this.follows = f || [];
        this.predecessor = predecessor;
        this.id = parseInt(production.id+&#039;a&#039;+this.dotPosition, 36);
        this.markedSymbol = this.production.handle[this.dotPosition];
    },
    remainingHandle: function () {
        return this.production.handle.slice(this.dotPosition+1);
    },
    eq: function (e) {
        return e.id === this.id;
    },
    handleToString: function () {
        var handle = this.production.handle.slice(0);
        handle[this.dotPosition] = &#039;.&#039;+(handle[this.dotPosition]||&#039;&#039;);
        return handle.join(&#039; &#039;);
    },
    toString: function () {
        var temp = this.production.handle.slice(0);
        temp[this.dotPosition] = &#039;.&#039;+(temp[this.dotPosition]||&#039;&#039;);
        return this.production.symbol+&quot; -&gt; &quot;+temp.join(&#039; &#039;) +
            (this.follows.length === 0 ? &quot;&quot; : &quot; #lookaheads= &quot;+this.follows.join(&#039; &#039;));
    }
});

lrGeneratorMixin.ItemSet = Set.prototype.construct({
    afterconstructor: function () {
        this.reductions = [];
        this.goes = {};
        this.edges = {};
        this.shifts = false;
        this.inadequate = false;
        this.hash_ = {};
        for (var i=this._items.length-1;i &gt;=0;i--) {
            this.hash_[this._items[i].id] = true; //i;
        }
    },
    concat: function concat (set) {
        var a = set._items || set;
        for (var i=a.length-1;i &gt;=0;i--) {
            this.hash_[a[i].id] = true; //i;
        }
        this._items.push.apply(this._items, a);
        return this;
    },
    push: function (item) {
        this.hash_[item.id] = true;
        return this._items.push(item);
    },
    contains: function (item) {
        return this.hash_[item.id];
    },
    valueOf: function toValue () {
        var v = this._items.map(function (a) {return a.id;}).sort().join(&#039;|&#039;);
        this.valueOf = function toValue_inner() {return v;};
        return v;
    }
});

lrGeneratorMixin.closureOperation = function closureOperation (itemSet /*, closureSet*/) {
    var closureSet = new this.ItemSet();
    var self = this;

    var set = itemSet,
        itemQueue, syms = {};

    do {
    itemQueue = new Set();
    closureSet.concat(set);
    set.forEach(function CO_set_forEach (item) {
        var symbol = item.markedSymbol;

        // if token is a non-terminal, recursively add closures
        if (symbol &amp;&amp; self.nonterminals[symbol]) {
            if(!syms[symbol]) {
                self.nonterminals[symbol].productions.forEach(function CO_nt_forEach (production) {
                    var newItem = new self.Item(production, 0);
                    if(!closureSet.contains(newItem))
                        itemQueue.push(newItem);
                });
                syms[symbol] = true;
            }
        } else if (!symbol) {
            // reduction
            closureSet.reductions.push(item);
            closureSet.inadequate = closureSet.reductions.length &gt; 1 || closureSet.shifts;
        } else {
            // shift
            closureSet.shifts = true;
            closureSet.inadequate = closureSet.reductions.length &gt; 0;
        }
    });

    set = itemQueue;

    } while (!itemQueue.isEmpty());

    return closureSet;
};

lrGeneratorMixin.gotoOperation = function gotoOperation (itemSet, symbol) {
    var gotoSet = new this.ItemSet(),
        self = this;

    itemSet.forEach(function goto_forEach(item, n) {
        if (item.markedSymbol === symbol) {
            gotoSet.push(new self.Item(item.production, item.dotPosition+1, item.follows, n));
        }
    });

    return gotoSet.isEmpty() ? gotoSet : this.closureOperation(gotoSet);
};

/* Create unique set of item sets
 * */
lrGeneratorMixin.canonicalCollection = function canonicalCollection () {
    var item1 = new this.Item(this.productions[0], 0, [this.EOF]);
    var firstState = this.closureOperation(new this.ItemSet(item1)),
        states = new Set(firstState),
        marked = 0,
        self = this,
        itemSet;

    states.has = {};
    states.has[firstState] = 0;

    while (marked !== states.size()) {
        itemSet = states.item(marked); marked++;
        itemSet.forEach(function CC_itemSet_forEach (item) {
            if (item.markedSymbol &amp;&amp; item.markedSymbol !== self.EOF)
                self.canonicalCollectionInsert(item.markedSymbol, itemSet, states, marked-1);
        });
    }

    return states;
};

// Pushes a unique state into the que. Some parsing algorithms may perform additional operations
lrGeneratorMixin.canonicalCollectionInsert = function canonicalCollectionInsert (symbol, itemSet, states, stateNum) {
    var g = this.gotoOperation(itemSet, symbol);
    if (!g.predecessors)
        g.predecessors = {};
    // add g to que if not empty or duplicate
    if (!g.isEmpty()) {
        var gv = g.valueOf(),
            i = states.has[gv];
        if (i === -1 || typeof i === &#039;undefined&#039;) {
            states.has[gv] = states.size();
            itemSet.edges[symbol] = states.size(); // store goto transition for table
            states.push(g);
            g.predecessors[symbol] = [stateNum];
        } else {
            itemSet.edges[symbol] = i; // store goto transition for table
            states.item(i).predecessors[symbol].push(stateNum);
        }
    }
};

var NONASSOC = 0;
lrGeneratorMixin.parseTable = function parseTable (itemSets) {
    var states = [],
        nonterminals = this.nonterminals,
        operators = this.operators,
        conflictedStates = {}, // array of [state, token] tuples
        self = this,
        s = 1, // shift
        r = 2, // reduce
        a = 3; // accept

    // for each item set
    itemSets.forEach(function (itemSet, k) {
        var state = states[k] = {};
        var action, stackSymbol;

        // set shift and goto actions
        for (stackSymbol in itemSet.edges) {
            itemSet.forEach(function (item, j) {
                // find shift and goto actions
                if (item.markedSymbol == stackSymbol) {
                    var gotoState = itemSet.edges[stackSymbol];
                    if (nonterminals[stackSymbol]) {
                        // store state to go to after a reduce
                        //self.trace(k, stackSymbol, &#039;g&#039;+gotoState);
                        state[self.symbols_[stackSymbol]] = gotoState;
                    } else {
                        //self.trace(k, stackSymbol, &#039;s&#039;+gotoState);
                        state[self.symbols_[stackSymbol]] = [s,gotoState];
                    }
                }
            });
        }

        // set accept action
        itemSet.forEach(function (item, j) {
            if (item.markedSymbol == self.EOF) {
                // accept
                state[self.symbols_[self.EOF]] = [a];
                //self.trace(k, self.EOF, state[self.EOF]);
            }
        });

        var allterms = self.lookAheads ? false : self.terminals;

        // set reductions and resolve potential conflicts
        itemSet.reductions.forEach(function (item, j) {
            // if parser uses lookahead, only enumerate those terminals
            var terminals = allterms || self.lookAheads(itemSet, item);

            terminals.forEach(function (stackSymbol) {
                action = state[self.symbols_[stackSymbol]];
                var op = operators[stackSymbol];

                // Reading a terminal and current position is at the end of a production, try to reduce
                if (action || action &amp;&amp; action.length) {
                    var sol = resolveConflict(item.production, op, [r,item.production.id], action[0] instanceof Array ? action[0] : action);
                    self.resolutions.push([k,stackSymbol,sol]);
                    if (sol.bydefault) {
                        self.conflicts++;
                        if (!self.DEBUG) {
                            self.warn(&#039;Conflict in grammar: multiple actions possible when lookahead token is &#039;,stackSymbol,&#039; in state &#039;,k, &quot;\n- &quot;, printAction(sol.r, self), &quot;\n- &quot;, printAction(sol.s, self));
                            conflictedStates[k] = true;
                        }
                        if (self.options.noDefaultResolve) {
                            if (!(action[0] instanceof Array))
                                action = [action];
                            action.push(sol.r);
                        }
                    } else {
                        action = sol.action;
                    }
                } else {
                    action = [r,item.production.id];
                }
                if (action &amp;&amp; action.length) {
                    state[self.symbols_[stackSymbol]] = action;
                } else if (action === NONASSOC) {
                    state[self.symbols_[stackSymbol]] = undefined;
                }
            });
        });

    });

    if (!self.DEBUG &amp;&amp; self.conflicts &gt; 0) {
        self.warn(&quot;\nStates with conflicts:&quot;);
        each(conflictedStates, function (val, state) {
            self.warn(&#039;State &#039;+state);
            self.warn(&#039;  &#039;,itemSets.item(state).join(&quot;\n  &quot;));
        });
    }

    return states;
};

// find states with only one action, a reduction
function findDefaults (states) {
    var defaults = {};
    states.forEach(function (state, k) {
        var i = 0;
        for (var act in state) {
             if ({}.hasOwnProperty.call(state, act)) i++;
        }

        if (i === 1 &amp;&amp; state[act][0] === 2) {
            // only one action in state and it&#039;s a reduction
            defaults[k] = state[act];
        }
    });

    return defaults;
}

// resolves shift-reduce and reduce-reduce conflicts
function resolveConflict (production, op, reduce, shift) {
    var sln = {production: production, operator: op, r: reduce, s: shift},
        s = 1, // shift
        r = 2, // reduce
        a = 3; // accept

    if (shift[0] === r) {
        sln.msg = &quot;Resolve R/R conflict (use first production declared in grammar.)&quot;;
        sln.action = shift[1] &lt; reduce[1] ? shift : reduce;
        if (shift[1] !== reduce[1]) sln.bydefault = true;
        return sln;
    }

    if (production.precedence === 0 || !op) {
        sln.msg = &quot;Resolve S/R conflict (shift by default.)&quot;;
        sln.bydefault = true;
        sln.action = shift;
    } else if (production.precedence &lt; op.precedence ) {
        sln.msg = &quot;Resolve S/R conflict (shift for higher precedent operator.)&quot;;
        sln.action = shift;
    } else if (production.precedence === op.precedence) {
        if (op.assoc === &quot;right&quot; ) {
            sln.msg = &quot;Resolve S/R conflict (shift for right associative operator.)&quot;;
            sln.action = shift;
        } else if (op.assoc === &quot;left&quot; ) {
            sln.msg = &quot;Resolve S/R conflict (reduce for left associative operator.)&quot;;
            sln.action = reduce;
        } else if (op.assoc === &quot;nonassoc&quot; ) {
            sln.msg = &quot;Resolve S/R conflict (no action for non-associative operator.)&quot;;
            sln.action = NONASSOC;
        }
    } else {
        sln.msg = &quot;Resolve conflict (reduce for higher precedent production.)&quot;;
        sln.action = reduce;
    }

    return sln;
}

lrGeneratorMixin.generate = function parser_generate (opt) {
    opt = typal.mix.call({}, this.options, opt);
    var code = &quot;&quot;;

    // check for illegal identifier
    if (!opt.moduleName || !opt.moduleName.match(/^[A-Za-z_$][A-Za-z0-9_$]*$/)) {
        opt.moduleName = &quot;parser&quot;;
    }
    switch (opt.moduleType) {
        case &quot;js&quot;:
            code = this.generateModule(opt);
            break;
        case &quot;amd&quot;:
            code = this.generateAMDModule(opt);
            break;
        default:
            code = this.generateCommonJSModule(opt);
            break;
    }

    return code;
};

lrGeneratorMixin.generateAMDModule = function generateAMDModule(opt){
    opt = typal.mix.call({}, this.options, opt);
    var module = this.generateModule_();
    var out = &#039;\n\ndefine(function(require){\n&#039;
        + module.commonCode
        + &#039;\nvar parser = &#039;+ module.moduleCode
        + &quot;\n&quot;+this.moduleInclude
        + (this.lexer &amp;&amp; this.lexer.generateModule ?
          &#039;\n&#039; + this.lexer.generateModule() +
          &#039;\nparser.lexer = lexer;&#039; : &#039;&#039;)
        + &#039;\nreturn parser;&#039;
        + &#039;\n});&#039;
    return out;
};

lrGeneratorMixin.generateCommonJSModule = function generateCommonJSModule (opt) {
    opt = typal.mix.call({}, this.options, opt);
    var moduleName = opt.moduleName || &quot;parser&quot;;
    var out = this.generateModule(opt)
        + &quot;\n\n\nif (typeof require !== &#039;undefined&#039; &amp;&amp; typeof exports !== &#039;undefined&#039;) {&quot;
        + &quot;\nexports.parser = &quot;+moduleName+&quot;;&quot;
        + &quot;\nexports.Parser = &quot;+moduleName+&quot;.Parser;&quot;
        + &quot;\nexports.parse = function () { return &quot;+moduleName+&quot;.parse.apply(&quot;+moduleName+&quot;, arguments); };&quot;
        + &quot;\nexports.main = &quot;+ String(opt.moduleMain || commonjsMain) + &quot;;&quot;
        + &quot;\nif (typeof module !== &#039;undefined&#039; &amp;&amp; require.main === module) {\n&quot;
        + &quot;  exports.main(process.argv.slice(1));\n}&quot;
        + &quot;\n}&quot;;

    return out;
};

lrGeneratorMixin.generateModule = function generateModule (opt) {
    opt = typal.mix.call({}, this.options, opt);
    var moduleName = opt.moduleName || &quot;parser&quot;;
    var out = &quot;/* parser generated by jison &quot; + version + &quot; */\n&quot;
        + &quot;/*\n&quot;
        + &quot;  Returns a Parser object of the following structure:\n&quot;
        + &quot;\n&quot;
        + &quot;  Parser: {\n&quot;
        + &quot;    yy: {}\n&quot;
        + &quot;  }\n&quot;
        + &quot;\n&quot;
        + &quot;  Parser.prototype: {\n&quot;
        + &quot;    yy: {},\n&quot;
        + &quot;    trace: function(),\n&quot;
        + &quot;    symbols_: {associative list: name ==&gt; number},\n&quot;
        + &quot;    terminals_: {associative list: number ==&gt; name},\n&quot;
        + &quot;    productions_: [...],\n&quot;
        + &quot;    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),\n&quot;
        + &quot;    table: [...],\n&quot;
        + &quot;    defaultActions: {...},\n&quot;
        + &quot;    parseError: function(str, hash),\n&quot;
        + &quot;    parse: function(input),\n&quot;
        + &quot;\n&quot;
        + &quot;    lexer: {\n&quot;
        + &quot;        EOF: 1,\n&quot;
        + &quot;        parseError: function(str, hash),\n&quot;
        + &quot;        setInput: function(input),\n&quot;
        + &quot;        input: function(),\n&quot;
        + &quot;        unput: function(str),\n&quot;
        + &quot;        more: function(),\n&quot;
        + &quot;        less: function(n),\n&quot;
        + &quot;        pastInput: function(),\n&quot;
        + &quot;        upcomingInput: function(),\n&quot;
        + &quot;        showPosition: function(),\n&quot;
        + &quot;        test_match: function(regex_match_array, rule_index),\n&quot;
        + &quot;        next: function(),\n&quot;
        + &quot;        lex: function(),\n&quot;
        + &quot;        begin: function(condition),\n&quot;
        + &quot;        popState: function(),\n&quot;
        + &quot;        _currentRules: function(),\n&quot;
        + &quot;        topState: function(),\n&quot;
        + &quot;        pushState: function(condition),\n&quot;
        + &quot;\n&quot;
        + &quot;        options: {\n&quot;
        + &quot;            ranges: boolean           (optional: true ==&gt; token location info will include a .range[] member)\n&quot;
        + &quot;            flex: boolean             (optional: true ==&gt; flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)\n&quot;
        + &quot;            backtrack_lexer: boolean  (optional: true ==&gt; lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)\n&quot;
        + &quot;        },\n&quot;
        + &quot;\n&quot;
        + &quot;        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),\n&quot;
        + &quot;        rules: [...],\n&quot;
        + &quot;        conditions: {associative list: name ==&gt; set},\n&quot;
        + &quot;    }\n&quot;
        + &quot;  }\n&quot;
        + &quot;\n&quot;
        + &quot;\n&quot;
        + &quot;  token location info (@$, _$, etc.): {\n&quot;
        + &quot;    first_line: n,\n&quot;
        + &quot;    last_line: n,\n&quot;
        + &quot;    first_column: n,\n&quot;
        + &quot;    last_column: n,\n&quot;
        + &quot;    range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)\n&quot;
        + &quot;  }\n&quot;
        + &quot;\n&quot;
        + &quot;\n&quot;
        + &quot;  the parseError function receives a &#039;hash&#039; object with these members for lexer and parser errors: {\n&quot;
        + &quot;    text:        (matched text)\n&quot;
        + &quot;    token:       (the produced terminal token, if any)\n&quot;
        + &quot;    line:        (yylineno)\n&quot;
        + &quot;  }\n&quot;
        + &quot;  while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {\n&quot;
        + &quot;    loc:         (yylloc)\n&quot;
        + &quot;    expected:    (string describing the set of expected tokens)\n&quot;
        + &quot;    recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)\n&quot;
        + &quot;  }\n&quot;
        + &quot;*/\n&quot;;
    out += (moduleName.match(/\./) ? moduleName : &quot;var &quot;+moduleName) +
            &quot; = &quot; + this.generateModuleExpr();

    return out;
};


lrGeneratorMixin.generateModuleExpr = function generateModuleExpr () {
    var out = &#039;&#039;;
    var module = this.generateModule_();

    out += &quot;(function(){\n&quot;;
    out += module.commonCode;
    out += &quot;\nvar parser = &quot;+module.moduleCode;
    out += &quot;\n&quot;+this.moduleInclude;
    if (this.lexer &amp;&amp; this.lexer.generateModule) {
        out += this.lexer.generateModule();
        out += &quot;\nparser.lexer = lexer;&quot;;
    }
    out += &quot;\nfunction Parser () {\n  this.yy = {};\n}\n&quot;
        + &quot;Parser.prototype = parser;&quot;
        + &quot;parser.Parser = Parser;&quot;
        + &quot;\nreturn new Parser;\n})();&quot;;

    return out;
};

function addTokenStack (fn) {
    var parseFn = fn;
    try {
        var ast = esprima.parse(parseFn);
        var stackAst = esprima.parse(String(tokenStackLex)).body[0];
        stackAst.id.name = &#039;lex&#039;;

        var labeled = JSONSelect.match(&#039;:has(:root &gt; .label &gt; .name:val(&quot;_token_stack&quot;))&#039;, ast);

        labeled[0].body = stackAst;

        return escodegen.generate(ast).replace(/_token_stack:\s?/,&quot;&quot;).replace(/\\\\n/g,&quot;\\n&quot;);
    } catch (e) {
        return parseFn;
    }
}

// lex function that supports token stacks
function tokenStackLex() {
    var token;
    token = tstack.pop() || lexer.lex() || EOF;
    // if token isn&#039;t its numeric value, convert
    if (typeof token !== &#039;number&#039;) {
        if (token instanceof Array) {
            tstack = token;
            token = tstack.pop();
        }
        token = self.symbols_[token] || token;
    }
    return token;
}

// returns parse function without error recovery code
function removeErrorRecovery (fn) {
    var parseFn = fn;
    try {
        var ast = esprima.parse(parseFn);

        var labeled = JSONSelect.match(&#039;:has(:root &gt; .label &gt; .name:val(&quot;_handle_error&quot;))&#039;, ast);
        var reduced_code = labeled[0].body.consequent.body[3].consequent.body;
        reduced_code[0] = labeled[0].body.consequent.body[1];     // remove the line: error_rule_depth = locateNearestErrorRecoveryRule(state);
        reduced_code[4].expression.arguments[1].properties.pop(); // remove the line: &#039;recoverable: error_rule_depth !== false&#039;
        labeled[0].body.consequent.body = reduced_code;

        return escodegen.generate(ast).replace(/_handle_error:\s?/,&quot;&quot;).replace(/\\\\n/g,&quot;\\n&quot;);
    } catch (e) {
        return parseFn;
    }
}

// Generates the code of the parser module, which consists of two parts:
// - module.commonCode: initialization code that should be placed before the module
// - module.moduleCode: code that creates the module object
lrGeneratorMixin.generateModule_ = function generateModule_ () {
    var parseFn = String(parser.parse);
    if (!this.hasErrorRecovery) {
      parseFn = removeErrorRecovery(parseFn);
    }

    if (this.options[&#039;token-stack&#039;]) {
      parseFn = addTokenStack(parseFn);
    }

    // Generate code with fresh variable names
    nextVariableId = 0;
    var tableCode = this.generateTableCode(this.table);

    // Generate the initialization code
    var commonCode = tableCode.commonCode;

    // Generate the module creation code
    var moduleCode = &quot;{&quot;;
    moduleCode += [
        &quot;trace: &quot; + String(this.trace || parser.trace),
        &quot;yy: {}&quot;,
        &quot;symbols_: &quot; + JSON.stringify(this.symbols_),
        &quot;terminals_: &quot; + JSON.stringify(this.terminals_).replace(/&quot;([0-9]+)&quot;:/g,&quot;$1:&quot;),
        &quot;productions_: &quot; + JSON.stringify(this.productions_),
        &quot;performAction: &quot; + String(this.performAction),
        &quot;table: &quot; + tableCode.moduleCode,
        &quot;defaultActions: &quot; + JSON.stringify(this.defaultActions).replace(/&quot;([0-9]+)&quot;:/g,&quot;$1:&quot;),
        &quot;parseError: &quot; + String(this.parseError || (this.hasErrorRecovery ? traceParseError : parser.parseError)),
        &quot;parse: &quot; + parseFn
        ].join(&quot;,\n&quot;);
    moduleCode += &quot;};&quot;;

    return { commonCode: commonCode, moduleCode: moduleCode }
};

// Generate code that represents the specified parser table
lrGeneratorMixin.generateTableCode = function (table) {
    var moduleCode = JSON.stringify(table);
    var variables = [createObjectCode];

    // Don&#039;t surround numerical property name numbers in quotes
    moduleCode = moduleCode.replace(/&quot;([0-9]+)&quot;(?=:)/g, &quot;$1&quot;);

    // Replace objects with several identical values by function calls
    // e.g., { 1: [6, 7]; 3: [6, 7], 4: [6, 7], 5: 8 } = o([1, 3, 4], [6, 7], { 5: 8 })
    moduleCode = moduleCode.replace(/\{\d+:[^\}]+,\d+:[^\}]+\}/g, function (object) {
        // Find the value that occurs with the highest number of keys
        var value, frequentValue, key, keys = {}, keyCount, maxKeyCount = 0,
            keyValue, keyValues = [], keyValueMatcher = /(\d+):([^:]+)(?=,\d+:|\})/g;

        while ((keyValue = keyValueMatcher.exec(object))) {
            // For each value, store the keys where that value occurs
            key = keyValue[1];
            value = keyValue[2];
            keyCount = 1;

            if (!(value in keys)) {
                keys[value] = [key];
            } else {
                keyCount = keys[value].push(key);
            }
            // Remember this value if it is the most frequent one
            if (keyCount &gt; maxKeyCount) {
                maxKeyCount = keyCount;
                frequentValue = value;
            }
        }
        // Construct the object with a function call if the most frequent value occurs multiple times
        if (maxKeyCount &gt; 1) {
            // Collect all non-frequent values into a remainder object
            for (value in keys) {
                if (value !== frequentValue) {
                    for (var k = keys[value], i = 0, l = k.length; i &lt; l; i++) {
                        keyValues.push(k[i] + &#039;:&#039; + value);
                    }
                }
            }
            keyValues = keyValues.length ? &#039;,{&#039; + keyValues.join(&#039;,&#039;) + &#039;}&#039; : &#039;&#039;;
            // Create the function call `o(keys, value, remainder)`
            object = &#039;o([&#039; + keys[frequentValue].join(&#039;,&#039;) + &#039;],&#039; + frequentValue + keyValues + &#039;)&#039;;
        }
        return object;
    });

    // Count occurrences of number lists
    var list;
    var lists = {};
    var listMatcher = /\[[0-9,]+\]/g;

    while (list = listMatcher.exec(moduleCode)) {
        lists[list] = (lists[list] || 0) + 1;
    }

    // Replace frequently occurring number lists with variables
    moduleCode = moduleCode.replace(listMatcher, function (list) {
        var listId = lists[list];
        // If listId is a number, it represents the list&#039;s occurrence frequency
        if (typeof listId === &#039;number&#039;) {
            // If the list does not occur frequently, represent it by the list
            if (listId === 1) {
                lists[list] = listId = list;
            // If the list occurs frequently, represent it by a newly assigned variable
            } else {
                lists[list] = listId = createVariable();
                variables.push(listId + &#039;=&#039; + list);
            }
        }
        return listId;
    });

    // Return the variable initialization code and the table code
    return {
        commonCode: &#039;var &#039; + variables.join(&#039;,&#039;) + &#039;;&#039;,
        moduleCode: moduleCode
    };
};
// Function that extends an object with the given value for all given keys
// e.g., o([1, 3, 4], [6, 7], { x: 1, y: 2 }) = { 1: [6, 7]; 3: [6, 7], 4: [6, 7], x: 1, y: 2 }
var createObjectCode = &#039;o=function(k,v,o,l){&#039; +
    &#039;for(o=o||{},l=k.length;l--;o[k[l]]=v);&#039; +
    &#039;return o}&#039;;

// Creates a variable with a unique name
function createVariable() {
    var id = nextVariableId++;
    var name = &#039;$V&#039;;

    do {
        name += variableTokens[id % variableTokensLength];
        id = ~~(id / variableTokensLength);
    } while (id !== 0);

    return name;
}

var nextVariableId = 0;
var variableTokens = &#039;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_$&#039;;
var variableTokensLength = variableTokens.length;

// default main method for generated commonjs modules
function commonjsMain (args) {
    if (!args[1]) {
        console.log(&#039;Usage: &#039;+args[0]+&#039; FILE&#039;);
        process.exit(1);
    }
    var source = require(&#039;fs&#039;).readFileSync(require(&#039;path&#039;).normalize(args[1]), &quot;utf8&quot;);
    return exports.parser.parse(source);
}

// debug mixin for LR parser generators

function printAction (a, gen) {
    var s = a[0] == 1 ? &#039;shift token (then go to state &#039;+a[1]+&#039;)&#039; :
        a[0] == 2 ? &#039;reduce by rule: &#039;+gen.productions[a[1]] :
                    &#039;accept&#039; ;

    return s;
}

var lrGeneratorDebug = {
    beforeparseTable: function () {
        this.trace(&quot;Building parse table.&quot;);
    },
    afterparseTable: function () {
        var self = this;
        if (this.conflicts &gt; 0) {
            this.resolutions.forEach(function (r, i) {
                if (r[2].bydefault) {
                    self.warn(&#039;Conflict at state: &#039;,r[0], &#039;, token: &#039;,r[1], &quot;\n  &quot;, printAction(r[2].r, self), &quot;\n  &quot;, printAction(r[2].s, self));
                }
            });
            this.trace(&quot;\n&quot;+this.conflicts+&quot; Conflict(s) found in grammar.&quot;);
        }
        this.trace(&quot;Done.&quot;);
    },
    aftercanonicalCollection: function (states) {
        var trace = this.trace;
        trace(&quot;\nItem sets\n------&quot;);

        states.forEach(function (state, i) {
            trace(&quot;\nitem set&quot;,i,&quot;\n&quot;+state.join(&quot;\n&quot;), &#039;\ntransitions -&gt; &#039;, JSON.stringify(state.edges));
        });
    }
};

var parser = typal.beget();

lrGeneratorMixin.createParser = function createParser () {

    var p = eval(this.generateModuleExpr());

    // for debugging
    p.productions = this.productions;

    var self = this;
    function bind(method) {
        return function() {
            self.lexer = p.lexer;
            return self[method].apply(self, arguments);
        };
    }

    // backwards compatability
    p.lexer = this.lexer;
    p.generate = bind(&#039;generate&#039;);
    p.generateAMDModule = bind(&#039;generateAMDModule&#039;);
    p.generateModule = bind(&#039;generateModule&#039;);
    p.generateCommonJSModule = bind(&#039;generateCommonJSModule&#039;);

    return p;
};

parser.trace = generator.trace;
parser.warn = generator.warn;
parser.error = generator.error;

function traceParseError (err, hash) {
    this.trace(err);
}

function parseError (str, hash) {
    if (hash.recoverable) {
        this.trace(str);
    } else {
        var error = new Error(str);
        error.hash = hash;
        throw error;
    }
}

parser.parseError = lrGeneratorMixin.parseError = parseError;

parser.parse = function parse (input) {
    var self = this,
        stack = [0],
        tstack = [], // token stack
        vstack = [null], // semantic value stack
        lstack = [], // location stack
        table = this.table,
        yytext = &#039;&#039;,
        yylineno = 0,
        yyleng = 0,
        recovering = 0,
        TERROR = 2,
        EOF = 1;

    var args = lstack.slice.call(arguments, 1);

    //this.reductionCount = this.shiftCount = 0;

    var lexer = Object.create(this.lexer);
    var sharedState = { yy: {} };
    // copy state
    for (var k in this.yy) {
      if (Object.prototype.hasOwnProperty.call(this.yy, k)) {
        sharedState.yy[k] = this.yy[k];
      }
    }

    lexer.setInput(input, sharedState.yy);
    sharedState.yy.lexer = lexer;
    sharedState.yy.parser = this;
    if (typeof lexer.yylloc == &#039;undefined&#039;) {
        lexer.yylloc = {};
    }
    var yyloc = lexer.yylloc;
    lstack.push(yyloc);

    var ranges = lexer.options &amp;&amp; lexer.options.ranges;

    if (typeof sharedState.yy.parseError === &#039;function&#039;) {
        this.parseError = sharedState.yy.parseError;
    } else {
        this.parseError = Object.getPrototypeOf(this).parseError;
    }

    function popStack (n) {
        stack.length = stack.length - 2 * n;
        vstack.length = vstack.length - n;
        lstack.length = lstack.length - n;
    }

_token_stack:
    var lex = function () {
        var token;
        token = lexer.lex() || EOF;
        // if token isn&#039;t its numeric value, convert
        if (typeof token !== &#039;number&#039;) {
            token = self.symbols_[token] || token;
        }
        return token;
    }

    var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;
    while (true) {
        // retreive state number from top of stack
        state = stack[stack.length - 1];

        // use default actions if available
        if (this.defaultActions[state]) {
            action = this.defaultActions[state];
        } else {
            if (symbol === null || typeof symbol == &#039;undefined&#039;) {
                symbol = lex();
            }
            // read action for current state and first input
            action = table[state] &amp;&amp; table[state][symbol];
        }

_handle_error:
        // handle parse error
        if (typeof action === &#039;undefined&#039; || !action.length || !action[0]) {
            var error_rule_depth;
            var errStr = &#039;&#039;;

            // Return the rule stack depth where the nearest error rule can be found.
            // Return FALSE when no error recovery rule was found.
            function locateNearestErrorRecoveryRule(state) {
                var stack_probe = stack.length - 1;
                var depth = 0;

                // try to recover from error
                for(;;) {
                    // check for error recovery rule in this state
                    if ((TERROR.toString()) in table[state]) {
                        return depth;
                    }
                    if (state === 0 || stack_probe &lt; 2) {
                        return false; // No suitable error recovery rule available.
                    }
                    stack_probe -= 2; // popStack(1): [symbol, action]
                    state = stack[stack_probe];
                    ++depth;
                }
            }

            if (!recovering) {
                // first see if there&#039;s any chance at hitting an error recovery rule:
                error_rule_depth = locateNearestErrorRecoveryRule(state);

                // Report error
                expected = [];
                for (p in table[state]) {
                    if (this.terminals_[p] &amp;&amp; p &gt; TERROR) {
                        expected.push(&quot;&#039;&quot;+this.terminals_[p]+&quot;&#039;&quot;);
                    }
                }
                if (lexer.showPosition) {
                    errStr = &#039;Parse error on line &#039;+(yylineno+1)+&quot;:\n&quot;+lexer.showPosition()+&quot;\nExpecting &quot;+expected.join(&#039;, &#039;) + &quot;, got &#039;&quot; + (this.terminals_[symbol] || symbol)+ &quot;&#039;&quot;;
                } else {
                    errStr = &#039;Parse error on line &#039;+(yylineno+1)+&quot;: Unexpected &quot; +
                                  (symbol == EOF ? &quot;end of input&quot; :
                                              (&quot;&#039;&quot;+(this.terminals_[symbol] || symbol)+&quot;&#039;&quot;));
                }
                this.parseError(errStr, {
                    text: lexer.match,
                    token: this.terminals_[symbol] || symbol,
                    line: lexer.yylineno,
                    loc: yyloc,
                    expected: expected,
                    recoverable: (error_rule_depth !== false)
                });
            } else if (preErrorSymbol !== EOF) {
                error_rule_depth = locateNearestErrorRecoveryRule(state);
            }

            // just recovered from another error
            if (recovering == 3) {
                if (symbol === EOF || preErrorSymbol === EOF) {
                    throw new Error(errStr || &#039;Parsing halted while starting to recover from another error.&#039;);
                }

                // discard current lookahead and grab another
                yyleng = lexer.yyleng;
                yytext = lexer.yytext;
                yylineno = lexer.yylineno;
                yyloc = lexer.yylloc;
                symbol = lex();
            }

            // try to recover from error
            if (error_rule_depth === false) {
                throw new Error(errStr || &#039;Parsing halted. No suitable error recovery rule available.&#039;);
            }
            popStack(error_rule_depth);

            preErrorSymbol = (symbol == TERROR ? null : symbol); // save the lookahead token
            symbol = TERROR;         // insert generic error symbol as new lookahead
            state = stack[stack.length-1];
            action = table[state] &amp;&amp; table[state][TERROR];
            recovering = 3; // allow 3 real symbols to be shifted before reporting a new error
        }

        // this shouldn&#039;t happen, unless resolve defaults are off
        if (action[0] instanceof Array &amp;&amp; action.length &gt; 1) {
            throw new Error(&#039;Parse Error: multiple actions possible at state: &#039;+state+&#039;, token: &#039;+symbol);
        }

        switch (action[0]) {
            case 1: // shift
                //this.shiftCount++;

                stack.push(symbol);
                vstack.push(lexer.yytext);
                lstack.push(lexer.yylloc);
                stack.push(action[1]); // push state
                symbol = null;
                if (!preErrorSymbol) { // normal execution/no error
                    yyleng = lexer.yyleng;
                    yytext = lexer.yytext;
                    yylineno = lexer.yylineno;
                    yyloc = lexer.yylloc;
                    if (recovering &gt; 0) {
                        recovering--;
                    }
                } else {
                    // error just occurred, resume old lookahead f/ before error
                    symbol = preErrorSymbol;
                    preErrorSymbol = null;
                }
                break;

            case 2:
                // reduce
                //this.reductionCount++;

                len = this.productions_[action[1]][1];

                // perform semantic action
                yyval.$ = vstack[vstack.length-len]; // default to $$ = $1
                // default location, uses first token for firsts, last for lasts
                yyval._$ = {
                    first_line: lstack[lstack.length-(len||1)].first_line,
                    last_line: lstack[lstack.length-1].last_line,
                    first_column: lstack[lstack.length-(len||1)].first_column,
                    last_column: lstack[lstack.length-1].last_column
                };
                if (ranges) {
                  yyval._$.range = [lstack[lstack.length-(len||1)].range[0], lstack[lstack.length-1].range[1]];
                }
                r = this.performAction.apply(yyval, [yytext, yyleng, yylineno, sharedState.yy, action[1], vstack, lstack].concat(args));

                if (typeof r !== &#039;undefined&#039;) {
                    return r;
                }

                // pop off stack
                if (len) {
                    stack = stack.slice(0,-1*len*2);
                    vstack = vstack.slice(0, -1*len);
                    lstack = lstack.slice(0, -1*len);
                }

                stack.push(this.productions_[action[1]][0]);    // push nonterminal (reduce)
                vstack.push(yyval.$);
                lstack.push(yyval._$);
                // goto new state = table[STATE][NONTERMINAL]
                newState = table[stack[stack.length-2]][stack[stack.length-1]];
                stack.push(newState);
                break;

            case 3:
                // accept
                return true;
        }

    }

    return true;
};

parser.init = function parser_init (dict) {
    this.table = dict.table;
    this.defaultActions = dict.defaultActions;
    this.performAction = dict.performAction;
    this.productions_ = dict.productions_;
    this.symbols_ = dict.symbols_;
    this.terminals_ = dict.terminals_;
};

/*
 * LR(0) Parser
 * */

var lr0 = generator.beget(lookaheadMixin, lrGeneratorMixin, {
    type: &quot;LR(0)&quot;,
    afterconstructor: function lr0_afterconstructor () {
        this.buildTable();
    }
});

var LR0Generator = exports.LR0Generator = lr0.construct();

/*
 * Simple LALR(1)
 * */

var lalr = generator.beget(lookaheadMixin, lrGeneratorMixin, {
    type: &quot;LALR(1)&quot;,

    afterconstructor: function (grammar, options) {
        if (this.DEBUG) this.mix(lrGeneratorDebug, lalrGeneratorDebug); // mixin debug methods

        options = options || {};
        this.states = this.canonicalCollection();
        this.terms_ = {};

        var newg = this.newg = typal.beget(lookaheadMixin,{
            oldg: this,
            trace: this.trace,
            nterms_: {},
            DEBUG: false,
            go_: function (r, B) {
                r = r.split(&quot;:&quot;)[0]; // grab state #
                B = B.map(function (b) { return b.slice(b.indexOf(&quot;:&quot;)+1); });
                return this.oldg.go(r, B);
            }
        });
        newg.nonterminals = {};
        newg.productions = [];

        this.inadequateStates = [];

        // if true, only lookaheads in inadequate states are computed (faster, larger table)
        // if false, lookaheads for all reductions will be computed (slower, smaller table)
        this.onDemandLookahead = options.onDemandLookahead || false;

        this.buildNewGrammar();
        newg.computeLookaheads();
        this.unionLookaheads();

        this.table = this.parseTable(this.states);
        this.defaultActions = findDefaults(this.table);
    },

    lookAheads: function LALR_lookaheads (state, item) {
        return (!!this.onDemandLookahead &amp;&amp; !state.inadequate) ? this.terminals : item.follows;
    },
    go: function LALR_go (p, w) {
        var q = parseInt(p, 10);
        for (var i=0;i&lt;w.length;i++) {
            q = this.states.item(q).edges[w[i]] || q;
        }
        return q;
    },
    goPath: function LALR_goPath (p, w) {
        var q = parseInt(p, 10),t,
            path = [];
        for (var i=0;i&lt;w.length;i++) {
            t = w[i] ? q+&quot;:&quot;+w[i] : &#039;&#039;;
            if (t) this.newg.nterms_[t] = q;
            path.push(t);
            q = this.states.item(q).edges[w[i]] || q;
            this.terms_[t] = w[i];
        }
        return {path: path, endState: q};
    },
    // every disjoint reduction of a nonterminal becomes a produciton in G&#039;
    buildNewGrammar: function LALR_buildNewGrammar () {
        var self = this,
            newg = this.newg;

        this.states.forEach(function (state, i) {
            state.forEach(function (item) {
                if (item.dotPosition === 0) {
                    // new symbols are a combination of state and transition symbol
                    var symbol = i+&quot;:&quot;+item.production.symbol;
                    self.terms_[symbol] = item.production.symbol;
                    newg.nterms_[symbol] = i;
                    if (!newg.nonterminals[symbol])
                        newg.nonterminals[symbol] = new Nonterminal(symbol);
                    var pathInfo = self.goPath(i, item.production.handle);
                    var p = new Production(symbol, pathInfo.path, newg.productions.length);
                    newg.productions.push(p);
                    newg.nonterminals[symbol].productions.push(p);

                    // store the transition that get&#039;s &#039;backed up to&#039; after reduction on path
                    var handle = item.production.handle.join(&#039; &#039;);
                    var goes = self.states.item(pathInfo.endState).goes;
                    if (!goes[handle])
                        goes[handle] = [];
                    goes[handle].push(symbol);

                    //self.trace(&#039;new production:&#039;,p);
                }
            });
            if (state.inadequate)
                self.inadequateStates.push(i);
        });
    },
    unionLookaheads: function LALR_unionLookaheads () {
        var self = this,
            newg = this.newg,
            states = !!this.onDemandLookahead ? this.inadequateStates : this.states;

        states.forEach(function union_states_forEach (i) {
            var state = typeof i === &#039;number&#039; ? self.states.item(i) : i,
                follows = [];
            if (state.reductions.length)
            state.reductions.forEach(function union_reduction_forEach (item) {
                var follows = {};
                for (var k=0;k&lt;item.follows.length;k++) {
                    follows[item.follows[k]] = true;
                }
                state.goes[item.production.handle.join(&#039; &#039;)].forEach(function reduction_goes_forEach (symbol) {
                    newg.nonterminals[symbol].follows.forEach(function goes_follows_forEach (symbol) {
                        var terminal = self.terms_[symbol];
                        if (!follows[terminal]) {
                            follows[terminal]=true;
                            item.follows.push(terminal);
                        }
                    });
                });
                //self.trace(&#039;unioned item&#039;, item);
            });
        });
    }
});

var LALRGenerator = exports.LALRGenerator = lalr.construct();

// LALR generator debug mixin

var lalrGeneratorDebug = {
    trace: function trace () {
        Jison.print.apply(null, arguments);
    },
    beforebuildNewGrammar: function () {
        this.trace(this.states.size()+&quot; states.&quot;);
        this.trace(&quot;Building lookahead grammar.&quot;);
    },
    beforeunionLookaheads: function () {
        this.trace(&quot;Computing lookaheads.&quot;);
    }
};

/*
 * Lookahead parser definitions
 *
 * Define base type
 * */
var lrLookaheadGenerator = generator.beget(lookaheadMixin, lrGeneratorMixin, {
    afterconstructor: function lr_aftercontructor () {
        this.computeLookaheads();
        this.buildTable();
    }
});

/*
 * SLR Parser
 * */
var SLRGenerator = exports.SLRGenerator = lrLookaheadGenerator.construct({
    type: &quot;SLR(1)&quot;,

    lookAheads: function SLR_lookAhead (state, item) {
        return this.nonterminals[item.production.symbol].follows;
    }
});


/*
 * LR(1) Parser
 * */
var lr1 = lrLookaheadGenerator.beget({
    type: &quot;Canonical LR(1)&quot;,

    lookAheads: function LR_lookAheads (state, item) {
        return item.follows;
    },
    Item: lrGeneratorMixin.Item.prototype.construct({
        afterconstructor: function () {
            this.id = this.production.id+&#039;a&#039;+this.dotPosition+&#039;a&#039;+this.follows.sort().join(&#039;,&#039;);
        },
        eq: function (e) {
            return e.id === this.id;
        }
    }),

    closureOperation: function LR_ClosureOperation (itemSet /*, closureSet*/) {
        var closureSet = new this.ItemSet();
        var self = this;

        var set = itemSet,
            itemQueue, syms = {};

        do {
        itemQueue = new Set();
        closureSet.concat(set);
        set.forEach(function (item) {
            var symbol = item.markedSymbol;
            var b, r;

            // if token is a nonterminal, recursively add closures
            if (symbol &amp;&amp; self.nonterminals[symbol]) {
                r = item.remainingHandle();
                b = self.first(item.remainingHandle());
                if (b.length === 0 || item.production.nullable || self.nullable(r)) {
                    b = b.concat(item.follows);
                }
                self.nonterminals[symbol].productions.forEach(function (production) {
                    var newItem = new self.Item(production, 0, b);
                    if(!closureSet.contains(newItem) &amp;&amp; !itemQueue.contains(newItem)) {
                        itemQueue.push(newItem);
                    }
                });
            } else if (!symbol) {
                // reduction
                closureSet.reductions.push(item);
            }
        });

        set = itemQueue;
        } while (!itemQueue.isEmpty());

        return closureSet;
    }
});

var LR1Generator = exports.LR1Generator = lr1.construct();

/*
 * LL Parser
 * */
var ll = generator.beget(lookaheadMixin, {
    type: &quot;LL(1)&quot;,

    afterconstructor: function ll_aftercontructor () {
        this.computeLookaheads();
        this.table = this.parseTable(this.productions);
    },
    parseTable: function llParseTable (productions) {
        var table = {},
            self = this;
        productions.forEach(function (production, i) {
            var row = table[production.symbol] || {};
            var tokens = production.first;
            if (self.nullable(production.handle)) {
                Set.union(tokens, self.nonterminals[production.symbol].follows);
            }
            tokens.forEach(function (token) {
                if (row[token]) {
                    row[token].push(i);
                    self.conflicts++;
                } else {
                    row[token] = [i];
                }
            });
            table[production.symbol] = row;
        });

        return table;
    }
});

var LLGenerator = exports.LLGenerator = ll.construct();

Jison.Generator = function Jison_Generator (g, options) {
    var opt = typal.mix.call({}, g.options, options);
    switch (opt.type) {
        case &#039;lr0&#039;:
            return new LR0Generator(g, opt);
        case &#039;slr&#039;:
            return new SLRGenerator(g, opt);
        case &#039;lr&#039;:
            return new LR1Generator(g, opt);
        case &#039;ll&#039;:
            return new LLGenerator(g, opt);
        default:
            return new LALRGenerator(g, opt);
    }
};

return function Parser (g, options) {
        var gen = Jison.Generator(g, options);
        return gen.createParser();
    };

})();</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ cyclomatic }} <br>
    Length : {{ halstead.length }} <br>
    Difficulty : {{ halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
